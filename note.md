
# Notes

## Trap

0. $\Huge \text{long  long}$
1. ``pool[++ptr]=x``/ `` return pool[ptr--];``
2. ``treap`` ``rem``里也要``pushup``
3. 左右儿子为空时``pushodown``要注意特判啊
4. ``splay`` 有 ``rev`` 标记时查 ``kth`` 时注意左儿子 ``sz``（先 ``pushdown`` 再 ``if``）
5. 不要 ``while(a)a=tr[a].rs`` 而是 ``while(tr[a].rs)``
6. ``splay`` 里面 ``rotate(x)`` 后记得 ``y=tr[x].fa``
7. 提交前注释删完……**不要忘记换行的``if(xxx)``**(cf1206E）
8. ``SA``的 $ca,cb$ 开到 $N$ 而不是 $C$ 
9. ``SA`` 第一步 $ca$ ``for``到值域(多测清空时注意 $i\leq max(n,26)\to ca[i]=0;$）
10. 多项式操作迭代时开 $2$ 倍大小
11. 快速写记得 ``fwrite``
12. 多项式 $\omega,\omega^{-1}$ 预处理不要写错
13. 多项式 $\ln$ 记得 ``resize``
14. ``add``\\``mul``函数一定一定不要打错！不然调到死！！！
15. 多个数组感觉要排序时先看是否一定相关！可以无关的利用好条件！
16. ``pushup``时如果有无关变量注意不要被默认清空了！！！如 $len,sz$ 等等
17. 写``pushdown``先看``x``有没有标记...不要上来就``pushdown``了
18. ``rotate``里 $fa[x]=z$ 而不是 $p$ 
19. ``pushup`` 多考虑几下（乘法标记有没有乘 $0$ ,取 $\max$ 的下标是 $mx[lx]>n$ 而不是 $lx>n$ ）
20. 点分树``for``每个儿子时 $mxdep$ 不一定单增时 $mxdep$ 要赋值
21. ``for``语句执行 ``(A;B;C){D}`` $执行A\to判断B\to执行D\to执行C\to判断B\to\cdots$
22. 点分治``for``儿子之前 ``temp=total-sz[u];`` 然后对于每个儿子``total=sz[v]>sz[u]?temp:sz[v];``
23. 线性递推求特征多项式，最开始补 $1$，然后其余要记得取反
24. 虚树,每次读入的a数组空间开 $2n$ (``lca``可能有重复）
25. ``qpow(a,b)`` 如果b是``long long``记得先 $\mod \text{MOD}-1$ 而不是在``qpow``里被强转后再取模
26. ``DLX``中 ``remove`` 和 ``resume``，一个 $R$ 开始则另一个 $L$ 开始,先后顺序有要求
27. 二分边界取第一个小于等于 $x$ 的位置，如果全都小于，初值不设好容易挂，最好设为 $l-1$
28. 等比数列求和注意是否存在公比为 $1$
29. 圆方树点数 $2n$ ,边数 $4n$ ,注意取对数后加 $1$ ,边数 $N<<2$
30. **三目操作符``?``注意先后顺序以及运算符优先级**
31. 树上问题有求LCA不要忘了预处理``fa[u][i]``
32. 注意题面中是单向还是双向边
33. ``SA`` 记得进行前缀和以及用 $A,B$ 而不是 $rk$ 数组排序
34. $int(-1.5+0.5)=int(-2)=-2$  ``double``四舍五入注意； $-1/2=0$ （默认向 $0$ 取整）
35. ``adde``和``add``不要混用!!!少了 30pts！
36. $mask$ 看清是 $=lst$ 还是 $\oplus=lst$
37. ``treap``中``del``的时候``rot``后要递归到``ch[x][!t]``如果是权值的话``t?mid:l``要变为``t?l:mid``
38. ``del``最好在 $x$ 时``rebuild``而不是``ch[x][t]``处,因为可能根节点即为所求
39. 看清字符集是小写还是大写还是混用！(luogu ``SA``模版，``'z'->'Z'``, bzoj  wxh loves substring）
40. ``前缀和dp``时可以记个sum,每次 $sum+=转移来的dp值$，然后当前值 $+=sum$ ,注意是 $sum$ 不是转移来的 $dp$ 值
41. ``虚树``在弹开栈的时候直接 $dfn[st[i]]\geq dfn[st[t]]+sz[st[t]]$ 即可
42. ``sam``做多串最长公共子串时初始化时 $mn[u]=len[u]$,不然可能 $mx[u]=max(mx[fa[u]],mx[u])$导致$mx[fa[u]]>len[fa[u]]$
43. ``break``不要乱打,比如循环只进行了一次,剩余的暴力结果直接``break``掉就凉了(SP26073）
44. 二次剩余里``(ll)rand()<<15^rand()``而不是``rand()<<15^rand()``( $linux$ 下``RAND_MAX``为$2147483647$,``windows``下为 $32767$）否则可能爆负数(BZOJ5104）
45. ``广义sam``用线段树合并时多记个 $flag$ 表示是否为母串否则会乱合并!!!
46. 线段树合并，如果树上要查根以外的点需要新建点(否则 $u,v$ 合并后 $u$ 和 $w$ 合并时可能会改变 $v$ 一部分节点的值）
47. 合并两个线段树表示的链的虚树的方式: $sum[lk]+sum[rk]+dis(mn[k],mx[k]）+dis(mx[lk],mn[rk])-dis(mn[lk],mx[lk])-dis(mn[rk],mx[rk]);$ 其它写法如 $sum[lk]+sum[rk]+dis(lca(mn[lk],mx[lk]),lca(mn[rk],mx[rk]))$ 会被右边的 $mn,mx$ 都在其左边的子树内的情况hack
48. 数组开太大可能会在BZOJ上T!
49. ``kd树``找距离最大：直接四个角; 找距离最小不一定，比如在内部，或者在矩形正上方，还要判是否能连自身
50. ``lct``上有关子树的``access``后可能``ls``有之前在``x``和``fa[x]``之间的一些边
51. ``splay``上二分注意先``rx``还是先``lx``
52. ``kd树`` ``nth是`` ``st+l,st+mid,st+r+1``不是``st+l,st+mid,st+ptr+1`` !!!
53. ``kd树``,$0$ 号节点记得预处理!!!!!!!(bzoj2648)
54. 莫队时，``if(!vis[u]){if()...}else{}``的第一个``vis``后的大括号不要忘记打！！！``else``默认先和最近的结合
55. rmq, 倍增LCA等时 ``fa[N][lgN]``的 $lgN$ 取$\log_2N +2$ 因为一条链的话会使得 ``fa[u][log(N)/log(2)]``有值, 然后``fa[u][i-1]``会导致下标``[log(N)/log(2)+1]``被访问到，所以 $+2$
56. ``double`` 输入``%lf`` 输出``%f``
57. 线段树合并时 $l=r$ 时也要新建节点!!!，空间一定要开够！！
58. 动态开点``qry``到空的时候不一定``return l``可能``return ql``！！！(CF666E)
59. ``欧拉回路``对于奇度数点连虚点，但可能一个虚点也没有，要从第一个点开始``euler``而不是虚点
60. 莫队``if vis[x] mdy(x,y);``后记得``else col[x]=y;``!!!!!!
61. ``tarjan``时 $if(st[t+1]\neq u)$ 当 $u=0$ 为虚点时可能有问题
62. 二次离线莫队，注意什么时候对 $del$ 的贡献为正什么时候为负
63. ``ODT``里的``val``记得加上``mutable``
64. ``kd树`` ``rebuild`` 如果用st直接存的话 ``pushup``可能用到未初始化的 ``st[0]`` 导致复杂度退化(190709 C)
65. 多测``ecnt``清空！！
66. 二分图最大匹配每次清空 $vis$ !!
67. $x=x\&-x$ 在 $x=0$ 时也成立
68. 尺取法注意保证　$l\leq r$ (CF1199C)
69. 一些作为下标的临时变量注意是否会访问到 $-1$ !!! (CF1199C) (``g[cur-2]``)
70. 作为数组下标的变量是否加一要注意，记得大小开够
71. 黑白染色的时候判断颜色用 $(i+j)\&1$ 而不是用 $id[i][j]\&1$ 因为可能有没有``id``的点！！！
72. 网络流 ``n=100``的时候边也不能掉以轻心设为 $10^5$ ，cf1199E 就是 $50*100^2=5\times10^5$ 会大于 $10^5$ （RE on test 4)
73. 预处理看清楚是``for``到值域还是 $n$
74. ``dp``中刷表法和填表法不要混用
75. **看清楚题目中的 $n,m,k,q$ 等不要搞混！！！**(cf1207B)
76. 离散化数组数据多了注意开到 $2n$ 还是 $3n$ ! (cf 39 C)
77. 多维``dp``边界情况想清楚是``f[n+1]=n+1``还是``f[n+1]=sum+1`` (agc58F)
78. ``数位dp``和约数有关注意 $0$ ，以及只判断每个质数的幂来找因数（即只看 $2,4,8$ 来找 $2$ ；只看 $3,9$ 来找 $9$  ）不要忘了 $6$ 也是包含 $2,3$ 的约数
79. ``dfs``爆搜题 $WA$　可以尝试更改搜索顺序，可能是找到了一个“不合法的最优解”然后在 $ans=cur$ 时导致方案没被更新 (cf58E)
80. 数的位数如果每次前面写一个数位数不一定只是加一）因为如果之前有前导零没算进位数的话可能会改变很多如 $1\to1001$ ）有的题花的代价就不对了。可能需要先找一个正确的解之后不合法的情况在 $ans=cur$ 时直接``return``掉(我也不知道这题怎么过的，感觉这种假写法还是随便卡)(cf58E)
81. ``if(!x||vis[x])``而不是``if(!x&&vis[x])``不要搞混！！！(cf58C）
82. 同时预处理多个前缀和想清楚是 $1\sim n$ 还是 $n\sim1$ 
83. 前缀和处理时注意哪些地方可以取等
84. 模拟退火注意：
    - 不要把``swap``和``calc``函数顺序搞反！！！
    - 如果 $tmp>pre$ 时除了``chkmax(ans)``外还要 $pre=tmp$ ！！！
    (上面两条让 $70pts\to 30pts$）
85. 二维上滚动数组记得最后还会有一次``x^=y^=x^=y``，最后答案在 $y$ 上！
86. 滑动窗口时注意不要把需要保留的东西提前删掉了 $ins(x+d)\to v[x]\text{was deleted!}$ (cf372C）
87. 滚动数组``f[x/y][...]``要脑子一热把``qry(j)``写成``qry(x)``
88. ``sizeof dp[x]``不要打成``sizeof dp``，否则会把多余的东西覆盖
89. 特判一些小范围时看清题目要求，如“分成最少的集合”能否分成一个
90. ``z-algorithm``时注意 $ext[0]\leq min(n,m)$ 
91. ``z-algorithm``注意 $ext[x]$ 不要写成 $t[x]$
92. 分块题值域的 $L,R$ 和 $n$ 的 $bl,br$ 不要搞混
93. 值域分块 $pre[i][x]$ 减去一个数不能直接减一块的值 $pre[i][y]$
94. 有的边界情况写作 $st[n+1]=\Sigma +1$ 而不是 $n+1$ （agc58F）（或者直接判掉边界只``for``到 $n-1$） 
95. 有的奇怪题不是加边是完全图删边要看清（类似于概率给个 $1-p$ 的值）（hdu4997）
96. 有的边界特判 $0$ 之后枚举集合要从 $1$ 开始 (hdu4997）
97. 枚举子集时注意去掉最小值时是否可以算到自己，如果要减去一些东西的话尤其注意(hdu4997）
98. 一些离线的东西发现记的东西不够从``pair``改成``node``时注意之前的变量存的东西是否对应好了(190816flea）
99. 预处理关于子集的东西时注意是否会越界(uoj37）
100. 有边 $u\to v$ 时是 $in[v]++,out[u]++$ 不要搞反
101. 写``DP``前考虑清楚边界，不要看``std``写的好像是那样，实际抄出问题了
102. 有的时候一些辅助变量的值是 $+=cur$ 而不是 $=cur$ （uoj37）
103. 宏定义记得加括号！！（``#define f(x) f[x+zero]``在``f(dx=x+dir[0][k]）``时会出问题
104. 有时候``dp``不能转移的地方需要特判初始点(190818 wander）
105. ``printf(“%d\n”,ans>=0x3f3f3f?-1:ans);``非常容易出问题而且要调一年！！！（$0x3f3f3f=4144959\approx4\times 10^6$ 随便就卡了！！！）（hdu6658）应写成 $4$ 个的形式(``0x3f3f3f3f``）才是正确的！！！）
106. 在循环跳过一些变量时尤其注意 ``i=j+1``这样的写法会不会漏掉一些情况导致难写(cf1207C）
107. **特判一定要写对！！！**(cf1207C）
108. ``for``循环能``for``到 $n$ 不要``for``到 $n-1$ ！！！(cf1207F）
109. 大整数使用``pii`` 记为 $first\times base+second$ 时做带余运算记得加法不是直接加而是``pll(a.xx+b.xx+(a.yy+b.yy)/BASE,(a.yy+b.yy)%BASE)``（bzoj3811）
110. 答案不超过 $2^{63}$ 但是如果答案中有 $ans>>1$ 的话记得读入是``%llu``而不是``%lld`` (bzoj3811）
111. 线段树记录区间 $\min$ $\max$ 时注意值域！！！如果有负数时初值 $tr[x]=0$ 就会有问题！！！(而且注意哪些地方是一定不能为 $0$ 只能为 $-INF$ 的；哪些是可以为 $0$ 的，以及这个区间是否为空！！！$l>r$ ）（cf1208E）
112. **离散化最好把边界$+1$ $-1$ 都算上可能会有意想不到的越界（比如数组需要开 $3n$ 不是 $2n$ ）**
113. 预处理注意``for``准边界！！``for(int i=1;i<N;i++)tr[i]=-INF;``是错的应该``for``到``N<<2``！！！(cf1208E）
114. 选 $3$ 个不同的数时枚举第一个是枚举到 $n-2$ 而不是 $n$ ！！！（cf1208F）
115. 字符串建``trie``时注意数组大小开 $|S|+|T|$ (cf1207G）
116. **注意输出格式**如
     - 多组输出是否换行
     - 01串是否加空格
     - ``Ye5``和``N0``
117. 黑白染色每个点如果由左上确定注意第 $2k$ 行第一列是否有初始值(cf1206E）
118. 链表的删除操作注意不要执行多次！(190827 so）
119. 记搜时先特判 $step<0$ 再看 $vis[step][S]$ 免得访问负数下标 (190827 no）
120. 预处理 $bin[i]$ 不要写成 $fac[i]$ (190827 will）
121. 线段树上二分，如果需要左儿子来合并信息（如区间哈希）可以记成一个``pair``类型，第一个返回原来要求的东西，第二个返回区间用来合并的信息（如区间哈希），然后注意当 $l\leq ql\leq mid\leq qr\leq r$ 时也可能需要向上合并东西，不能不管第二维（而且如果要求连续的话必须保证左边取完了才能合并，有时候这个只用``pair``的``first``是不够的，比如如果左边有一个符合要求的但是不在``mid``，这时直接用 $lef.xx==-1$ 来判断左边取完没有就有问题）（总之要脑子清晰）（C3536）
122. ``multiset``删一个元素使用``mp.erase(mp.find(x))``否则会把值为 $x$ 的全删掉！
123. 读入的 $n,m$ 如果可交换要想清楚是换成 $n$ 大还是 $m$ 大！
124. **多测清空有的时候是 $0\sim n-1$ 而不是 $1\sim n$ ！！！**
125. 伯努利数直接求逆得到的是 $EGF$ 形式！！！要用的时候还要乘上一个阶乘！
126. ``tarjan``求点双是弹栈到 $v$ 不是 $u$ ！！！比如 $u$ 本身在一个大环上，伸出去一条到 $v$ 的边这种情况就可以看出来
127. 欧拉回路可以不连通！！！若干孤立点即可
128. 如果答案需要容斥拆分数一类的东西并且同时算答案和荣吃掉的拆分的时候，运用 ``polya定理`` 的顺序要想清楚，不要这里还没除以 |G|$ 就直接减去容斥的东西了，可以减去容斥的东西乘上 $\frac 1{|G|}$ （dsoj euler）
129. 答案容斥中出现之前的答案做可重组合的时候要注意如果第一项很大不能预处理但第二项很小的时候要每次暴力算下降幂的值
130. 换根``dp``注意是否会除以 $0$ ！！使用前缀后缀或者自定义一个``pair``表示有几个 $0$
131. ``ODT``一定记住要先插入节点！！否则在``it--``处会出现``begin()--``的ub
132. 链剖初值 $sz[0]=0$ !!! 因为是找 $sz$ 最大的儿子不是点分找 $mxs$ 最小的儿子
133. ``vector``做一些东西的时候直接 $!x$ 的想清楚这个 $0$ 是没有值还是在第 $0$ 项被更新过 （190923 tree）
134. 链剖总的链个数可以达到 $O(n)$ 而不是 $O(\log n)$ 后者是对一个点跳到根的路径而言的不要搞混了
135. ``FFT``精度误差非常大，记住要令 $eps=0.5$
136. ``FFT``使用 $wn$ 算误差非常大，但每次直接调用 $cos$ 和 $sin$ 太太太慢了，还是和``NTT``一样的预处理单位根，好得多 (cf632E)
137. 有的计算的东西到底是 $\%(MOD-1)$ 还是 $\%MOD$ 一定要想清楚 （cf632E）
138. 有的题要求太大了就输出``Too large``什么的不要写成 $\min(10^18+1)$ 下的形式。因为可能有两个方案是能够在``long double``域下比较大小的（现在全变成一样了）会导致找不到最优解（诗人小G）
139. ``Dsu on tree``时要记得保证信息是重儿子的子树而不是重链的信息的时候才可以直接调用（cf741D)
140. 定义在函数中而不是全局的自定义类型一定要设置初始化函数！！！
141. 分块可持久化并查集要记得是否需要赋 $tp=0$ 每次最多 $tp+=n$ （最好不要设成全局变量）
142. 有的题强制在线在没修改之前也要输出一个答案，记得这时候的 $lst$ 赋值 (uoj453)
143. 所有二维坐标点的排序想清楚需不需要第二关键字也排序（uoj198）
144. 190921调了一晚上……``int id(…) return 1ll*x*n+y`` 艹明明可以一A浪费太多时间了
145. $2^{32}-1$ 是``unsigned``范围内不是``int``（第 $31$ 位是符号位，``int``最大是 $2^{31}-1$ ）
146. 离散化后答案节点可能在线段树的两个节点之间需要特殊处理（APIO2018 新家）
147. $k$ 短路注意有无重边
148. 实数比较注意``eps``精度不可过低，能不用最好不用 （ $10^{-6}$ 都过不了 floj445 ）
149. 子集卷积注意数组要开到 $n+1$ 
150. ``splay`` 删除节点时即使是空也要 ``splay`` （而不是 ``assert`` 掉）（列队）（这样才能使得删 $rt$ 时能把 $rt$ 变成 $0$ ）
151. ``tarjan`` 缩点双是 pop 到 $v$ 而不是 $u$
152. 多测注意清空 $fa_{rt}$ 
153. min25 计算 $S$ 时枚举合数的最小质因子是要求 $prime_j^2\leq n$ 而不是 $prime_j\leq n$ 。否则每次 ``for`` 到 ``pcnt`` 复杂度无法承受





## Tricks

- 组合问题要能想到抽屉原理！
- 容斥集合时想到枚举最小值所在集合避免重复
- 组合数有关的有限制计数有的时候想``Lucas``定理来数位``dp``
- $4k\bigoplus 4k+1\bigoplus 4k+2 \bigoplus 4k+3=0$ （二进制只有最后两位不同）（可用来算 $1\sim n$的异或）
- 奇奇怪怪的卡空间交互题可以想 $FFT$ 的本质操作过程
- 多组询问每个二分复杂度 $O(n\log n)$ 可以想整体二分
- 奇怪的算几（如都是等边三角形）可以考虑换基
- $\lfloor\frac{x}{y}\rfloor=[x\geq y]+[x\geq 2y]+[x\geq 3y]+\cdots$
- 有向无环图最长路 $\to$ 拓扑排序
- 不好直接算但可以序列/树上相邻的转移的组合数（如上指标是距离当前点的距离）可以拆开 $\binom{n}{m}=\binom{n-1}{m-1}+\binom{n-1}{m}$
- 反演题可以看是否有上标的变量是不需要的如 $\sum_{j=0}^i{i\brace j}$ 在 $j>i$ 时为 $0$ 所以可以变成 $\sum_{j=0}^n{i\brace j}$
- 生成树的计数问题要联想到``prufer``序列
- 两个求和号算的相同分配方案的一些系数的值时候可以拆成类似于 $\sum_{i=1}^n\sum_{j=1,j\neq i}^n$ 的形式
- 数据范围 $100-500$ 想到网络流！
- 欧拉回路有时候要想到图的邻接表矩阵的线性基！
- 有些网格图上的``dp``实在不知道怎么优化了可以看对答案有影响的行/列是否很少可以只``dp``那一部分
- 打表的时候看是否可以某一列全部乘/除上对应的阶乘可能会有惊喜 190916
- 树形``dp`` $n^2$ 要想着能否合并每对父亲和儿子
- 长链剖分不好维护前缀信息考虑直接维护后缀和！
- 树上询问一些链的情况可以离线后点分，一种好写的实现方式是``solve(int u,const vector<node> v)`` 然后每次先遍历所有子树得到所有的标号，然后遍历 $v$ 中的每个询问，如果来自同一颗子树则``G[id[u].push_back(v[i])​``否则合并两个背包即可
- 空间限制太大的图论题可以试着不把边建出来，用的时候现算
- 模拟费用流有的回滚什么的太难算可以直接记录一个``visa[i]``和``visb[i]``，每次``while``堆顶不合法直接``pop``掉 (NOI2019 sequence)
- 图论题要想到简单的最小生成树...
- **求出现次数 $\geq k$ 的数的个数每次只对某个数出现次数加一或减一**可以直接记录答案,一次添加就``v[++cnt[x]]++``,一次删除就``--v[cnt[x]--]``
- 看到有关”平方”的数论题要想到二次剩余
- 可用 $01$ 表示的博弈如果多了一种平局尝试用 $\omega_3$ 表示
- 多项式每一项系数相同 $\Leftrightarrow$ ``IDFT``后只有 $0$ 次项不为 $0$ 
- 看到线性递推要想能否直接矩阵快速幂可能做法会简单得多（191024）
- ``floyd`` 加入中间点的顺序任意（比如从 $1$ 加到 $n$ 或从 $n$ 加到 $1$ 都能得到两点间最短路）
- $A(x)=\sum_{i=0}^na_ix^i\\\sum_{j=0}^n\left(\sum_{i=0}^n\binom{i}{j}q^{i-j}a_i\right)x^j=A(x+q)$
- 关于树的计数问题想到 prufer 序列！(200429 a)













|   范围    | 范围内因子个数最多的数 | 因数个数 |
| :-------: | ---------------------- | -------- |
|     1     | 1                      | 1        |
|    10     | 6                      | 4        |
|    100    | 60                     | 12       |
|   1000    | 840                    | 32       |
|   10000   | 7560                   | 64       |
|  100000   | 83160                  | 128      |
|  $10^6$   | 720720                 | 240      |
|  $10^7$   | 8648640                | 448      |
|  $10^8$   | 73513440               | 768      |
|  $10^9$   | 735134400              | 1344     |
| $10^{18}$ | 897612484786617600     | 103680   |







## Optmization

1. ``dp``中有 $0$ 不转移可能有很大优化 (BZOJ4851) ($9.9s\to2.6s$)
2. 稀疏矩阵乘法，有 $0$ 时不乘会快一半多 (BZOJ4851) ($2.6s\to1.1s$)
3. 二分图匹配，$10^5$ 个点时用``dinic``($0s$)而不是``ISAP``（$7s$)
4. 分块题数组大小能开成根号就开，不然 $256m$ 的空间可能都不够 (BZOJ5145)
5. $10^8$ 数组``memset``需要约 $50\sim 60\text{ms}$ (190803 $T1$)
6. 线性递推卡常： 

   - 计算多项式平方时可以减少``DFT``的次数

   - 使用多项式乘法及取模次数与指数的二进制表示下 1 的个数无关的快速幂写法

   - 预处理出``DFT``后的特征多项式及其逆
7. 预处理出 $100\dots$ 和 $111\dots$ 的数比枚举快了一个数量级？(A moon filled sky )3s(TLE)->1s(AC)
8. ``exlucas`` 在 $p=pk$ 的时候使用``lucas``有超级大大大大大大大大大大优化（FLOJ2190）
9. 李超树可以最优性剪枝快约 $1/3$
10. ``cin/cout`` ``ios_with_stdio(false)``后仍然比较慢
11. 拉格朗日反演(多项式运算)中多次用到一个多项式可以预处理出来
12. ``inc(a,b)``可能比``(a+=b)%=MOD``快 $0.5s$ (Floj2325)(从90pts到榜1)
13. 求``mex``可以值域分块，某些题可能比直接``while``小一半常数(BZOJ4129)
14. 矩阵乘法取模优化``ll Moc=8ll*MOD*MOD;..rr[i][j]+=1ll*a[i][k]*b[k][j];if(rr[i][j]>=Moc)rr[i][j]-=Moc;...c[i][j]=rr[i][j]%MOD,rr[i][j]=0;`` $85\to 100$ (FLOJ2366)
15. ``inc``直接用 $a=add(a,b)$ 比拆成和``add``一样的写法快得多，从70pts到100(n*26^3第二快)(Floj2348)
16. 字符串哈希
	- 预处理 $Base^k$ 
	
	- 手写``hash``（C3526 TLE 8/20->TLE 3/20）
	
	- 利用题目性质比如找``lcp``之类的长最多不超过 $len$ 则预先``chkmin(r,l+len-1)``
	
	- 一般``gp_hash_table``(查探法)快于``cc_hash_table``(拉链法)快于``unordered_map``快于``map``，但也有例外(C3526 菊花图时``gp``甚至慢于``unordered``…)(数据中TLE测试点数 $5: 4 : 8$ )
17. 光速幂（底数恒定）：预处理 $\sqrt{MOD}$ 个值，``qpow(n)``直接返回 $g[(n)>>15]\times f[(n)\&32767]$ (luogu5517)
18. 一定不要随随便便就``define``东西，比如``#define qpow(n) mul(g[(n)>>15],f[(n)&32767])``然后调用``qpow(n%(MOD-1))``的时候就整整多取模了一次！特别是卡常的毒瘤毒瘤毒瘤题 (luogu5517) (卡了 2h )
19. 特别卡常的使用种子生成数据的还分多个``subtask``时可以把判断最大那个``subtask``的放前面！！(就是先判``if(opt==2)``再判别的！！)
20. **读入量大( $10^6$ 左右个数大约 $10^7$ 左右的字符，文件大小直接除以 $2^{20}$ )的记得快读** 190902 nightmare (100pts->90pts) red(2.3s->1.6s)
21. $4m$ 左右大小的输出就可以考虑``write``来优化 (red 2.56s->1.42s)
22. 若每次修改只会影响常数棵线段树且询问是关于整棵树的 ，可以对每个 $rt$ 记录一个``vector``记录答案更改时间和对应答案，询问的时候在对应``vector``二分时间从而避免可持久化的空间问题
23. 并查集合并区间的时候注意是``j=rig[find(j)]+1``而不是直接``j++``否则 $n$ 次合并可能被卡到 $O(n^2)$
24. 数论题预处理也要注意复杂度能不带 $log$ 就不带，能少一个就少一个 (P5518)
25. 数位``dp``常数大的时候看下是否多乘了一个 $V$
26. 计算方案时若一个方案对应多种状态，考虑 dp 套 dp 即把“状态的集合”（$2^{|S|}$）看成状态（200530 T1）
27. 从 $k$ 个字符串中每个字符串选一个子序列并拼到一起形成的序列个数等于 $k$ 个字符串直接拼起来得到的子序列个数。






## Shortcut

| 系统                                     |                                                              |
| ---------------------------------------- | ------------------------------------------------------------ |
| Shift + F10                              | 显示选定项的快捷菜单。                                       |
| Windows 徽标键  + Ctrl + Shift + 数字    | 打开桌面，然后以管理员身份打开位于任务栏上指定位置的应用新实例。 |
| Windows 徽标键  + Shift + 向左键或向右键 | 将桌面上的应用或窗口从一台显示器移动至另一台显示器。         |
| Windows 徽标键‌  + Ctrl + Shift + B       | [从空白屏幕或黑屏中唤醒](https://support.microsoft.com/zh-cn/help/14106) |
| Windows 徽标键  + Pause                  | 显示“系统属性”对话框。                                       |
| Ctrl+Alt+’                               | 导数符号                                                     |


| 画图                               |                                                |
| ---------------------------------------- | ------------------------------------------------------------ |
| Ctrl + W                                 | 打开 “调整大小和扭曲” 对话框                                 |
| Ctrl + R                                 | 显示或隐藏标尺                                               |
| Ctrl + E                                 | 打开 “属性” 对话框                                           |
| Ctrl + G | 显示或隐藏网格线 |

| 计算器                         |                                                |
| ---------------------------------------- | ------------------------------------------------------------ |
| Ctrl+L/R/P/Q/M, Alt+M                             | 内存 MC/R/+/-/S |
| F3/4/5vqysot@Ctrl+gle%#Ctrl+yShift+s/o/trCtrl+nnm | 科学 |
| Delete,Esc,Backspace | 清除 |
| F9 | 正负            |
| F2/3/4 | Base64/32/16 |
| F4/5/6/7 | 16/10/8/2进制 |
|      <>\|^~&jk | 程序员 |

**注：Sinh Ctrl + s**



## Command

``VBoxManage modifyhd xxx.vdi --resize 204800``


``sudo usermod -aG vboxsf $(whoami)``

``powercfg -duplicatescheme e9a42b02-d5df-448d-aa00-03f14749eb61``

``evince *.pdf``

``less a.in``

``cat \proc\$(pidof a)\status``

``grep -i ‘mod’ *.cpp ``或``grep -R ‘mod’ –color``




## Vim

手动折叠 ``zfa{`` ``zA`` ``zC``

``diff`` 快捷跳转差异行``[c``

替换命令：每行所有+确认： ``/原串/新串/gc``

使用替换后使用``&``继续替换当前行剩下的

**windows:**
``nmap<F10> :!start cmd /c %<.exe&echo.&echo.______&size %<.exe&echo.&pause<Enter>``
**linux:(不常用)**
``nmap<F10> :!gnome-terminal -x bash -c 'time ./%<;echo '\n';size ./%<;read;'<Enter>``
**linux**下``<F9>``记得``<cr>`` ``<F10>``一定不``<cr>``



## HTML

<details>
  <summary>折叠时展示的文字</summary>
  展开内容。可以嵌套 markdown 语法。
</details>


## Latex

$$
\tiny a
\scriptsize a
\small a
\normalsize a
\large a
\Large a
\huge a
\Huge a\\
\Huge
a\!aa\,a\;a\ a\quad a\qquad a
$$

$$
\Huge
a\equiv c\pmod b
$$

$$
\Huge
\forall
\exists
\nexists
\therefore \because \And
$$

$$
\Huge
\approx
\sim
$$

$$
\Huge
\operatorname{lcm}a
\oplus
\otimes
\pm
$$

$$
\Huge
\cap
\bigcup
\subset
\supset
\emptyset
\varnothing
\subseteq \nsubseteq \subsetneq
$$

$$
\Huge
\dbinom{a}{b}
\binom{a}{b}
\tbinom{a}{b}
$$

$$
\tfrac{a}{b}
\frac{a}{b}
\cfrac{a}{b}
$$

$$
\Huge
f(x)=\begin{cases}
 x-1&x\leqslant3\\
 x^2+3x-1&x>3
 \end{cases}
$$


$$
{n\choose m}
{n\brace m}
{n\brack m}
$$

$$
\pm
\mp
$$



**注意：hexo 中不能出现 ``{{`` 的情况！！！**




## Ｃ＋＋

```c++
struct cmp{
	bool operator ()(int a,int b){return a<b;}
};

set<int,cmp>S;
priority_queue<int,vector<int>,cmp>q;

mt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());

inline void proc_status(){
	freopen("/proc/self/status","r",stderr);
  static char proc[1<<10];
  fread(proc,1,1<<20,stderr);
  printf("%s\n",proc);
}

//--------------------------------------------------don't use during contest

__int128 n;

unordered_map<ll,int>mp; //with c++11!!!

#include<ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
cc_hash_table <ll,int>mp;
gp_hash_table <ll,int>mp;
```
